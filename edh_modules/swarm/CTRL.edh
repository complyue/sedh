{##
 # This is the sentinel file stand in place of a host module that
 # should have been installed by the host interpreter, which contains
 # host procedures, classes and other artifacts defined via EHI
 # (which is obviously written in the host language i.e. Haskell)
 #
 # Execution of this module file is a sign showing that wrong Edh
 # interpreter is used to run the program.
 #}
if running!true # should be treated as false for proper control-flow analysis
then error( 'Missing host module: ' ++ __name__ )

# rest of the source here serves as meta documentation for aforementioned
# host artifacts, and is meant to be leveraged by IDE tools (such as els)
# with source code analysis capabilities, to aid the developers


export {

  {##
   # Computing Node Registry
   #
   #
   #}
  class NodeReg {

    method __init__(

      # Any value convertiable to string, usually `(expr { <statements> }).deBlock`, provides the default config content when a corresonding config file does not exist yet
      cfgDefault,

      # File path of the directory where node configuration files will be stored, an error will be thrown if this directory does not exist yet
      regDir= './etc',

    ) pass


    {## Get node configuration by MAC address

A new configuration file will be written with content from `cfgDefault`, if not existing yet; after that, the on disk file can be modified by hand or programmatically, then subsequent calls of `cfgOf()` will have disk file contents reloaded automatically. The `attrs` sandbox will be reused, so attributes in it will be reserved unless the config script would overwrite them.

     #}
    method cfgOf(mac= '00:00:00:00:00:00') return (

      # the content stored in corresponding config file
      src =: 'cfg stmts',

      # a (sandboxed) scope initially populated by evaluating the config file content, but can be arbitrarily updated subsequently, e.g. with reported data from heartbeats by the node after successfully booted
      attrs =: scope(),

      # the boot json payload conforming to pixieapi, whatever generated by the config script by `perform boot( ... )`
      boot =: blob() or None,

    )

    {## Save node configuration by MAC address

Always overwrite existing configuration file for the same mac, updated record is returned.

     #}
    method saveCfgSrc(mac, src) return (

      # the content stored in corresponding config file
      src =: 'cfg stmts',

      # a (sandboxed) scope initially populated by evaluating the config file content, but can be arbitrarily updated subsequently, e.g. with reported data from heartbeats by the node after successfully booted
      attrs =: scope(),

      # the boot json payload conforming to pixieapi, whatever generated by the config script by `perform boot( ... )`
      boot =: blob() or None,

    )


    {## List all known nodes

Only nodes ever triggered `cfgOf()` will be enumerated

They are usually triggered by either dhcp booting or heartbeating

     #}
    generator knownNodes() {
      yield (
        src =: 'cfg stmts',
        attrs =: scope(),
        boot =: blob() or None,
      )
      # multiple records to be yielded ...
    }

  }

}
