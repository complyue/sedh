
{#
 # forager for a swarm
 #}

import * 'swarm'

export method forageOn(
  swarmAddr    = '237.3.7.21',    # local addr to listen for call-for-workers
  swarmPort    = 3722,            # local port to listen for call-for-workers
  init         = None,            # peer module initialization
  foragerModu  = 'swarm/forage',  # the forager reacting module
) {
  case Forager(
    foragerModu,
    swarmAddr, swarmPort,
    init=init,
  ) of { forager } -> { pass }

  case forager.addrs() of { addrs } -> {
    console.info<| 'Foraging at: ' ++ addrs
  }

  # wait end-of-life for each worksource, log err if any
  go for peer from forager.worksources do { go {
    method _ (peer') {
      peer'.join() @=> { wsExc } -> {
        console.warn<| 'Worksource caused trouble - '
          ++ peer' ++ '\n' ++ wsExc
      }
    }
  } (peer) }
  # note an anoymous method is used above, to retain an attr named
  # `peer'`, locally in the procedure's scope, as the loop will
  # repeatedly change attr named `peer` in the outer scope

  return forager
}
