
{#
 # forager for a swarm node
 #}

import * 'net'

# will use classes there, but not to re-rexport them
import * 'swarm/forager/mgmt'


export method forageOn (
  headcount = 1, # number of worker processes to vend
  targetPrefix = '', # prefix to filter out uninteresting work
  swarmAddr = '0.0.0.0', # local addr to sniff for call-for-workers
  swarmPort = 3722, # local port to sniff for call-for-workers
  foragerModu = 'swarm/forager', # the forager reacting module
) {

  # artifacts should be implanted into the cfw facing module
  namespace cfw'arts () export {

    # the forager instance
    forager = Forager( headcount )

    # re-export (as to expose) forager's reacting (exported) methods there,
    # as to be callable by sniffed commands
    import * forager

  }

  # effects should be implanted into the cfw facing module
  namespace cfw'effs () export {

    method ignoreWorkModu( workModu ) case workModu of {
      { targetPrefix >@ _ } -> false
      _ -> true
    }

  }

  sniffer = Sniffer(
    # sniffer module
    foragerModu,
    # addr/port to sniff on
    swarmAddr, swarmPort,
    # sniffer module initializer
    init = method _ () {
      # implant the forager instance ets.
      import * cfw'arts into that
      # provide effects like filtering etc.
      effect import * cfw'effs into that
    },
  )

  case sniffer.addrs() of {
    { addr :>_ } -> console.info<| 'Foraging at: ' ++ addr
    # or the network has failed, propagate the error
    sniffer.join() # this usually throws
    # in case join() didn't throw, report this error
    error( 'Forager failed sniffing.' )
  }

  return sniffer
}
