
# this is the worksource facing entry module of an Edh swarm forager

import * 'net/symbols'
effect import * 'net/effects'

import ( Peer, **_ ) 'net/RT'

# work definition scripts are allowed to change the inferred configuration at
# 'swarm/ENV', import the module as a reference, to get/set effective artifacts
# living there
senv = { import (** _ ) 'swarm/ENV' }

import * 'swarm/forager/mgmt'


# this should have been implanted by per-connection peer module initialization
wsc ?= WSC()


# this should have been implanted by per-connection peer module preparation
peer ?= Peer()
console.debug<| 'Swarm forager negotiating with worksource - ' ++ peer
defer {
  console.debug<| 'Disconnecting worksource ' ++ peer
}

effect {
  ; @netPeer = peer
  ; @dataSink = peer.armChannel( dataChan, wsc.hcEmployed )
}


# we'll identify ourself as a forager to the worksource, as soon as the WSC
# is ready to receive employment confirmation events from the channel sink
; ( outlet = wsc.hcEmployed ) | () =>* {
  peer.postCommand( expr

    OfferHeads( {$ senv.swarmManagerPid $}, {$ wsc.hcReserved $} )

  )
}
# start the team keeper, it'll subscribe to wsc.hcEmployed, thus to kick off
# the producer above
go wsc.teamKeeper()


{

  while peer.eol() is false case peer.readCommand() of {
    # sequence of commands each resulting in nil are expected and let pass here
    { cmdVal } -> {
      console.warn<| 'Unexpected cmd from ' ++ peer ++ '\n  ' ++ cmdVal
      cmdVal = nil # clear it
    }
  }

} @=> { exc } -> {
  console.error<| 'Exception by worksource ' ++ peer
  ++ ' error: ' ++ exc
}
